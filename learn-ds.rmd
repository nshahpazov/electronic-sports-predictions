---
title: "learn-ds"
author: "Nikola Shahpazov"
date: "12/4/2020"
output: html_document
---

```{r package-setup, echo=FALSE, results='hide', warning=FALSE, message=FALSE} 

## Create the list of required packages
list.of.packages <- c(
  "magrittr",
  "tidyverse",
  "tidyquant",
  "caret",
  "ggplot2"
)

new.packages <- list.of.packages[(!list.of.packages %in% installed.packages() |
                                    list.of.packages %in% old.packages()[,"Package"])]

if (length(new.packages)) {
  install.packages(new.packages, repos = "http://cran.us.r-project.org")
}

## Load all necessary packages in RAM (working environment)
lapply(list.of.packages, require, character.only = TRUE)

## Setup working directory to the path of the source file location
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))

## Reproducibility 
SEED = 0

## Setup chunks options
knitr::opts_chunk$set(
    # message = FALSE,
    # warning = FALSE,
    fig.width = 8, 
    fig.height = 4.5,
    fig.align = 'center',
    out.width='95%', 
    dpi = 200
)
rstudioapi::writeRStudioPreference("data_viewer_max_columns", 1000L)
rm(list.of.packages,new.packages)
```

## First Steps

Let’s use our first graph to answer a question: do cars with big engines use more fuel than cars with small engines? You probably already have an answer, but try to make your answer precise. What does the relationship between engine size and fuel efficiency look like? Is it positive? Negative? Linear? Nonlinear?

```{r cars, echo=FALSE, warning=FALSE}
ggplot(mpg) +
  geom_point(mapping = aes(x = displ, y = hwy,
                           shape = fl, color = drv, size=class)) +

  stat_smooth(method = lm, mapping = aes(x = displ, y = hwy),
              level=0.99, fill = "pink") +

  ggtitle("Fuel saving wrt engine size") +
  theme_minimal()
```

```{r simple-example}
# just to check the idea of plotting mean in a bar plot
mpg[mpg$model == 'gti', 'year'] <- mpg[mpg$model == 'gti', 'year'] - 1000

mpg %>%
ggplot(mapping = aes(x = model, y = year)) +
  geom_bar(stat = "summary", fun = "mean", fill = "steelblue") +
  coord_flip() +
  theme_minimal()
```

```{r}
ggplot(mpg) +
  geom_point(mapping = aes(x = displ, y = hwy)) +
  stat_smooth(method = lm, mapping = aes(x = displ, y = hwy), level=0.99, fill = "pink") +
  ggtitle("Fuel saving wrt engine size") +
  theme_minimal()

model <- lm(hwy ~ displ, data = mpg)
f <- fitted(model)
sd2 <- sd(abs(model$residuals))*2


displ_std_error <- coef(summary(model))["displ", "Std. Error"] 

mpg <- mpg %>%
  mutate(g = ifelse(hwy > f + sd2, "economic",
                    ifelse(hwy < f - sd2, "not economic", "normal")))

mpg %>%
  ggplot() +
  geom_point(mapping = aes(x = displ, y = hwy, shape = fl, color = g)) +
  stat_smooth(method = lm, mapping = aes(x = displ, y = hwy), level=0.99, fill = "pink") +
  ggtitle("Fuel saving wrt engine size") +
  theme_minimal()
```

How can we hypothize regarding the outliers? Those cars might be some new type of car, perhaps a hybrid?

```{r plot-outliers, echo=FALSE}
mpg[mpg$g == 'not economic',] %>%
  ggplot() + geom_bar(mapping = aes(x = class))

mpg[mpg$g == 'economic',] %>%
  ggplot() + geom_bar(mapping = aes(x = class))
```

From those two plots we see that least economic cars are the suvs and pickups and the most ones are
the 2-seated cars


### a bit of magrittr exploration
```{r}
data.frame(z = rnorm(100)) %$%
  ts.plot(z) # you have access to the dataframe's name z

# initialization
x <- rnorm(100) %>%
  data.frame(z = .)

x <- 100
x %<>% rnorm()
```


### Faceting
```{r}
ggplot(mpg) +
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_wrap(~ class, ncol = 3)

ggplot(mpg) +
  geom_point(mapping = aes(x = displ, y = hwy)) +
  facet_grid(drv ~ cyl) # or if no y use . ~ cyl
```

```{r geoms}
ggplot(mpg) +
  geom_smooth(mapping = aes(x = displ, y = hwy, group = drv))

# global mapping
ggplot(mpg, mapping = aes(x = displ, y = hwy)) +
  geom_smooth() +
  # extend the default aesthetics
  geom_point(mapping = aes(color = class))

# you can apply the same idea for filtering data inside the ggplot

ggplot(mpg) +
  geom_smooth(mapping = aes(x = displ, y = hwy, group = drv))

# global mapping
ggplot(mpg, mapping = aes(x = displ, y = hwy)) +
  geom_smooth(data = filter(mpg, class == 'subcompact'), se = FALSE) + # remove the standard error
  # extend the default aesthetics
  geom_point(mapping = aes(color = class))

ggplot(data = mpg,
       mapping = aes(x = displ, y = hwy, color = drv)) +
geom_point() + geom_smooth(se = FALSE)
```

```{r stat-transformations}
ggplot(diamonds) +
  geom_bar(mapping = aes(x = cut))

ggplot(diamonds) +
  stat_count(mapping = aes(x = cut))

# this works before every stat has a default geom

ggplot(diamonds) +
  stat_count(mapping = aes(x = cut, y = 
                             prop
                           , group = 1), fill = "steelblue")

  ggplot(data = diamonds) + stat_summary(
  mapping = aes(x = cut, y = depth),
            fun.ymin = min,
            fun.ymax = max,
            fun.y = median
  )

```
### Positioning
```{r positioning}
ggplot(diamonds) +
  # position fill 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill") +
  theme_minimal()
# you can use one of three other options: "identity", "dodge" or fill
# position = "fill" works like stacking, but makes each set of stacked bars the same height. 
# This makes it easier to compare proportions across groups:

ggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) +
geom_bar(alpha = 1/5, position = "identity")

# position = "dodge" places overlapping objects directly beside one another.
# This makes it easier to compare individual values:
ggplot(diamonds) +
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge")

# The values of hwy and displ are rounded so the points appear on a grid and many points overlap each other. 
# This problem is known as overplotting. 

# You can avoid this gridding by setting the position adjustment to “jitter.” 
# position = "jitter" adds a small amount of random noise to each point. 
# This spreads the points out because no two points are likely to receive 
# the same amount of random noise:

ggplot(data = mpg) +
  # adds noise but shows all the points
  geom_point(mapping = aes(x = displ, y = hwy), position = "jitter")

# alternative
ggplot(data = mpg) +
  geom_jitter(mapping = aes(x = displ, y = hwy, color = manufacturer)) +
  coord_polar() # polar coordinates

```
### simple  example of dummy encoding
```{r oh-encoding}
customers <- data.frame(
  id=c(10, 20, 30, 40, 50),
  gender=c('male', 'female', 'female', 'male', 'female'),
  mood=c('happy', 'sad', 'happy', 'sad','happy'),
  outcome=c(1, 1, 0, 0, 0))

customers %>%
  dummyVars("~ gender", data = ., sep = ".", fullRank = TRUE) %>%
  predict(customers) %>%
  data.frame() %>%
  rename(gender_male = gendermale)
```
```{r}
ggplot(data = diamonds) +
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge") +
  coord_polar()

# emperical probability mass function (frequencies)
diamonds %>%
  group_by(cut) %>%
  count() %>% 
  mutate(n = n / nrow(diamonds)) %>% 
  ggplot(mapping = aes(x = cut, y = n, fill = cut)) +
  geom_bar(stat = "identity") +
  xlab("Different Cuts") +
  ylab("Probability")

# use grammar of graphics statistical transformation of the data
ggplot(diamonds, aes(x = cut, fill = cut)) +
  geom_bar(aes(y = stat(count / sum(count)))) +
  xlab("Different Cuts") +
  ylab("Probability") +
  coord_polar()

ggplot(diamonds, aes(x = "", fill = cut)) +
  geom_bar(aes(y = stat(count / sum(count)))) +
  xlab("Different Cuts") +
  ylab("Probability") +
  # TODO: add probability on top of the pie or in the legend
  coord_polar("y", start = 0) +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

ggplot(data = diamonds) +
  geom_histogram(mapping = aes(x = carat, fill = cut),
                 binwidth = 0.5, color = "black")

# by hand calculation of that
diamonds %>% count(cut_width(carat, 0.5))

# smaller exploration
smaller <- diamonds %>% filter(carat < 3)

# Asking questions
ggplot(data = smaller, mapping = aes(x = carat)) +
  geom_histogram(binwidth = 0.1)

ggplot(data = smaller, mapping = aes(x = carat)) +
  geom_histogram(binwidth = 0.01)

ggplot(data = faithful, mapping = aes(x = eruptions)) + 
  geom_histogram(binwidth = 0.25, fill = "steelblue", color = "black")
```
### Questions to ask and answers to give
* why are there more diamonds at whole carats and common fractions of carats
* why are there more slightly to the right of each peak?
* why are there no diamonds bigger than 3 carats?

* Clusters of similar values suggest that subgroups exist in your data. 
* To understand the subgroups, ask:

### More Questions
* How are the observations within each cluster similar to each other? Check mean and variance
* How are the observations in separate clusters different from each other?
* How can you explain or describe the clusters?
* Why might the appearance of clusters be misleading?


### Unusual Values
In the next plot we can see that the x axis is quite wide
```{r unusual-values}
ggplot(diamonds) + 
  geom_histogram(mapping = aes(x = y), binwidth = 0.5)

ggplot(diamonds) + 
  geom_histogram(mapping = aes(x = y), binwidth = 0.5) +
  coord_cartesian(xlim = c(0, 500), ylim = c(0, 20))


pivoted_diamonds <- diamonds %>%
  pivot_longer(cols = c("x", "y", "z"), names_to = "coord")

pivoted_diamonds %>%
  ggplot() +
    geom_histogram(mapping = aes(x = value, fill = cut),
                   binwidth = 0.5, color = "black") +
    facet_wrap(~ coord, ncol = 1)

pivoted_diamonds %>%
  ggplot(data = ., aes(x = value, fill = cut)) +
  geom_density(adjust = 2.5) +
  facet_wrap(~ coord, ncol = 1)

unusual_diamonds <- diamonds %>%
  filter(y < 3 | y > 20) %>%
  select(price, x, y, z) %>% arrange(y)

unusual_diamonds

ggplot(data = diamonds, mapping = aes(x = price, y = 
                                        density
                                      )) + 
  geom_freqpoly(mapping = aes(colour = cut), binwidth = 500)

```
The y variable measures one of the three dimensions of these diamonds, in mm. We know that diamonds can’t have a width of 0mm, so these values must be incorrect. We might also suspect that measurements of 32mm and 59mm are implausible:


### Missing values

```{r}
diamonds2 <- diamonds %>% 
  filter(between(y, 3, 20))

# filter outliers if they are incorrect data
inliered_diamonds <- diamonds %>% filter(between(y, 3, 20))

# better to replace the strange data with NAs and use a separate variable
usual_diamonds  <-  diamonds %>%
  mutate(y = ifelse(between(y, 3, 20), NA, y))

# understand missing data
nycflights13::flights %>%
  mutate(
    cancelled = is.na(dep_time),
     # will take the first two integers
    sched_hour = sched_dep_time %/% 100,
    sched_min = sched_dep_time %% 100,
    sched_dep_time = sched_hour + sched_min / 60
  ) %>%
  ggplot(mapping = aes(sched_dep_time)) +
  geom_freqpoly(mapping = aes(colour = cancelled), binwidth = 1/4)
```


### Boxplots
A boxplot is a type of visual shorthand for a distribution of values that is popular among statisticians. Each boxplot consists of:

* A box that stretches from the 25th percentile of the distribution to the 75th percentile, a distance known as the interquartile range (IQR).

* Visual points that display observations that fall more than 1.5 times the IQR from either edge of the box. These outlying points are unusual so are plotted individually.

* A line (or whisker) that extends from each end of the box and goes to the
farthest non-outlier point in the distribution.

```{r box-plots}
ggplot(diamonds, mapping = aes(x = cut, y = price, color = cut)) +
  geom_boxplot() +
  stat_summary(fun.y = mean, geom="point", shape = 23, size = 2)

ggplot(diamonds, mapping = aes(x = cut, y = price, fill = cut)) +
  geom_violin() +
  geom_boxplot(width = 0.1, color = "darkgrey") +
  theme_minimal() +
  coord_flip() +
  coord_cartesian()

ggplot(data = mpg, mapping = aes(x = class, y = hwy)) +
  geom_boxplot()

# To make the trend easier to see, we can reorder class based on the median value of hwy:
ggplot(data = mpg, mapping = aes(x = reorder(class, hwy, FUN = median),
                                 y = hwy,
                                 fill = class)) +
  geom_boxplot()
```


### Two categorical variables or two continuous ones
```{r two-categorical-variables}
ggplot(data = diamonds) +
  geom_count(mapping = aes(x = cut, y = color)) +
  ggtitle("Number of different colors in each cut")

# 2d histplot
diamonds %>% 
  count(color, cut) %>%
  ggplot(mapping = aes(x = color, y = cut)) +
  geom_tile(mapping = aes(fill = n / nrow(diamonds)))

ggplot(diamonds, aes(x = price, y = depth) ) +
  geom_hex(bins = 200) +
  scale_fill_continuous(type = "viridis") +
  theme_minimal() +
  coord_cartesian(ylim = c(55, 65), xlim = c(0, 10000))

ggplot(data = diamonds) +
  geom_hex(mapping = aes(x = carat, y = price)) +
  facet_wrap(~ color)

ggplot(data = smaller, mapping = aes(x = carat, y = price)) +
  geom_boxplot(mapping = aes(group = cut_width(carat, 0.2),
                             fill = cut_width(carat, 0.2)))

ggplot(data = smaller, mapping = aes(x = carat, y = price)) +
  geom_boxplot(mapping = aes(group = cut_width(carat, 0.2),
                             fill = cut_number(carat, 20)))
```

##### If you spot a pattern, ask yourself:
* Could this pattern be due to coincidence (i.e. random chance)?
* How can you describe the relationship implied by the pattern?
* How strong is the relationship implied by the pattern?
* What other variables might affect the relationship?
* Does the relationship change if you look at individual subgroups of the data?

```{r}
ggplot(data = faithful) +
  geom_point(mapping = aes(x = eruptions, y = waiting), color = "steelblue") +
  coord_flip()

ggplot() +
  geom_point(mapping = aes(x = faithful$waiting[-1],
                           y = diff(faithful$waiting, 1)),
             color = "steelblue") +
  xlab("waiting time") +
  ylab("waiting time minus one")
```

### Patterns and models

```{r}
library("modelr")
library("broom")

diamonds %>% ggplot(mapping = aes(x = log(carat), y = log(price))) +
  geom_point()

diamonds_model <- lm(log(price) ~ log(carat), data = diamonds)

summary(diamonds_model)

```